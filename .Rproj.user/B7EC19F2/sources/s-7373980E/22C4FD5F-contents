---
title: "Logue Lab - Song Matching Experiment - Data Handling and Analysis"
output:   
  html_document:
    keep_md: true
    theme: journal
    toc: true
    toc_depth: 4
    toc_float: 
      collapsed: false
    code_folding: hide
---

```{r Loading Libraries, message= FALSE, warning = FALSE}
library(lme4)
library(plyr)
library(ggplot2)
library(afex)
library(emmeans)
library(ggthemes)
library(tidyverse)
library(kableExtra)
library(Hmisc)
library(binom)
library(Rmisc)
library(magick)
library(webshot)
library(magrittr)
library(multcomp)
library(data.table)
library(here)

theme_alan <- function(base_size = 12 , base_family = "")
{
  half_line <- base_size/2
  colors <- ggthemes_data$few
  gray <- colors$medium["gray"]
  black <- colors$dark["black"]
  
  theme(
    line = element_line(colour = "black", size = 0.5, linetype = 1, lineend = "butt"),
    rect = element_rect(fill = "white", 
                        colour = "black", size = 0.5, linetype = 1),
    text = element_text(family = base_family, face = "plain", colour = "black", 
                        size = base_size, lineheight = 0.9, hjust = 0.5, vjust = 0.5,
                        angle = 0, margin = margin(), debug = FALSE),
    
    axis.line = element_blank(),
    axis.line.x = NULL,
    axis.line.y = NULL, 
    axis.text = element_text(size = rel(0.8), colour = "grey30"),
    axis.text.x = element_text(margin = margin(t = 0.8 * half_line/2), vjust = 1),
    axis.text.x.top = element_text(margin = margin(b = 0.8 * half_line/2), vjust = 0),
    axis.text.y = element_text(margin = margin(r = 0.8 * half_line/2), hjust = 1),
    axis.text.y.right = element_text(margin = margin(l = 0.8 * half_line/2), hjust = 0), 
    axis.ticks = element_line(colour = "grey20"), 
    axis.ticks.length = unit(half_line/2, "pt"),
    axis.title.x = element_text(margin = margin(t = half_line), vjust = 1),
    axis.title.x.top = element_text(margin = margin(b = half_line), vjust = 0),
    axis.title.y = element_text(angle = 90, margin = margin(r = half_line), vjust = 1),
    axis.title.y.right = element_text(angle = -90, margin = margin(l = half_line), vjust = 0),
    
    legend.background = element_rect(colour = NA),
    legend.spacing = unit(0.4, "cm"), 
    legend.spacing.x = NULL, 
    legend.spacing.y = NULL,
    legend.margin = margin(0.2, 0.2, 0.2, 0.2, "cm"),
    legend.key = element_rect(fill = "white", colour = NA), 
    legend.key.size = unit(1.2, "lines"), 
    legend.key.height = NULL,
    legend.key.width = NULL,
    legend.text = element_text(size = rel(0.8)), 
    legend.text.align = NULL,
    legend.title = element_text(hjust = 0),
    legend.title.align = NULL,
    legend.position = "right", 
    legend.direction = NULL,
    legend.justification = "center", 
    legend.box = NULL,
    legend.box.margin = margin(0, 0, 0, 0, "cm"),
    legend.box.background = element_blank(),
    legend.box.spacing = unit(0.4, "cm"),
    
    panel.background = element_rect(fill = "white", colour = NA),
    panel.border = element_rect(fill = NA, colour = "grey20"),
    panel.grid.major = element_line(colour = "grey92"),
    panel.grid.minor = element_line(colour = "grey92", size = 0.25),
    panel.spacing = unit(half_line, "pt"),
    panel.spacing.x = NULL,
    panel.spacing.y = NULL,
    panel.ontop = FALSE,
    
    strip.background = element_rect(fill = "NA", colour = "NA"),
    strip.text = element_text(colour = "grey10", size = rel(0.8)),
    strip.text.x = element_text(margin = margin(t = half_line, b = half_line)),
    strip.text.y = element_text(angle = 0, margin = margin(l = half_line, r = half_line)),
    strip.placement = "inside",
    strip.placement.x = NULL, 
    strip.placement.y = NULL,
    strip.switch.pad.grid = unit(0.1, "cm"), 
    strip.switch.pad.wrap = unit(0.1, "cm"), 
    
    plot.background = element_rect(colour = "white"),
    plot.title = element_text(size = rel(1.2), hjust = 0, vjust = 1, margin = margin(b = half_line * 1.2)),
    plot.subtitle = element_text(size = rel(0.9), hjust = 0, vjust = 1, margin = margin(b = half_line * 0.9)),
    plot.caption = element_text(size = rel(0.9), hjust = 1, vjust = 1, margin = margin(t = half_line * 0.9)), 
    plot.margin = margin(half_line, half_line, half_line, half_line),
    
    complete = TRUE)
}


```
# Introduction

The approach I'm taking here is to lay out all data wrangling and analyses using best practices. In future, this should get around issues of

a) file naming conventions
b) folder structure
c) "showing your work"

etc

That seem to plague multi-year and multi-student projects. Thus, this document will cover everything from experiment design to data analysis in order, with as many notes as I can put in as possible.

## Project Workflow

As with all things, its a great idea to lay out a project workflow. You can click on GO beneath to each of these sections to take you to the appropriate part of the document. You can also click through the table of contents for the same purpose.



# Experimental Design {#ExperimentDesign}

The first part of this project at least was collecting songs from birds. 

## Creating Stimlists
For most experiments, it is really beneficial to use the approach of creating Stimlists that are exhaustive, and that take the same format that our eventual data analysis will be happiest with - this keeps a through-line to our entire experiment where we always know what our columns mean, and can always relate data at any point to data from any other point and see how we got there, which is incredibly beneficial.

### Creating our Birdsong Stimuli
I am unsure what the original set of experimental stimuli was for this experiment, so we are reconstructing an idea of how to put this experiment together from scratch. But, for the sake of argument, **let's assume that we are creating our experiment based on 40 unique birdsongs**. These songs, without any manipulation, are our "Control" songs, but we can also either speed up ("Fast") or slow down ("Slow") these stimuli, giving us a total of 120 stims.

For the purposes of putting together this experiment, I've simply taken 60 songs from "DDLb dawn", copied them (for a total of 120 songs) and renamed them accordingly in the below code chunk (when you run this chunk the OldNames and NewNames vectors will already be the same, because the files were already renamed, but you can see how this went (the files that this was done with can be seen in the "Source" subfolder))

```{r Renaming Fake Stimuli Files, message= FALSE, warning = FALSE, results = "hide"}
#Empty files in the destination directory
file.remove(dir(here("Stimuli/Fake Stimuli"), pattern = ".aif", full.names = TRUE))

#Copy files from source to destination
SourceNames <- dir(here("Stimuli/Fake Stimuli/Source"),  full.names = TRUE, pattern = ".aif") 
file.copy(from = SourceNames,
          to = here("Stimuli/Fake Stimuli"),
          overwrite = TRUE)

#get the names of the files in the directory
OldNames <- dir(here("Stimuli/Fake Stimuli"),  full.names = TRUE, pattern = ".aif") 

#Create the combinations of Song number and Song Type, which will become the new filenames

BirdSongs <- paste(here("Stimuli/Fake Stimuli"), "/",  #File Path
                  rep("Song ", 120),   #Just the word "Song" 60 times
                  rep(1:40, 3), "-", # The numbers 1:20 3 times in a row
                  rep(c("Control", "Fast", "Slow"), each = 40), #"Control" 20 times, then "Fast" 20 times, etc.
                  ".aif", sep = "" )


#use file.rename to apply our new names
file.rename(OldNames, BirdSongs)

# Clean up our now not needed OldNames vector
rm(OldNames, SourceNames)

```

So now we have our set of songs, from which we want to construct our lists of stimuli (StimLists) for use in each playback experiment. 

In the real world, however, we'd likely be choosing this subset of songs for our experiment from a larger database of birdsongs from the species that we are studying- We might for example have say 1000 total songs from 50 birds that fall into 30 total song types (this is totally made up) - in such a case we would want a script that would choose randomly from this list in such a way that each Song Type was only used once. See [Appendix 1- Choosing Song Stimuli I](#ChoosingSongs) for an example of this kind of script.

In another case, there might actually be less than 20 overall Song Types, even though we need 20 individual songs for our Experiment for some reason. In this case, the selection procedure for each Stimlist would need to be a bit more careful. See [Appendix 2- Choosing Song Stimuli II](#ChoosingSongs2) for an example of this

### Creating Bird Band Permutations

For simplicity, we will assume here that we're going to be testing 30 birds, and we're going to test each of them in both types of trials (Dawn and A), so we'll have a total of 60 stimlists.

Lets set up the identities of our target birds. Obviously in the field this is done differently - but here we'll simply assume that each bird has two colored bands chosen from the following colors, but that no bird has two bands of the same color :
black (B), white (W), orange (O), red (R), green (G), yellow (Y). We can easily set up the permutations of these colors (and exclude two bands of the same color) by doing the following:

1. Creating a vector of our 6 color abbreviations
2. Obtaining the permutations of these colors using [expand.grid](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/expand.grid)
3. Removing permutations where both bands are the same color using the [subset](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) function


```{r Bird ID Permutations, message= FALSE, warning = FALSE}

#1- Creating a vector of our color abbreviations
colors <- c("B", "W", "O", "R", "G", "Y") #Make a vector of our color abbreviations

#2- Obtaining all permutations of these colors
BirdID <- expand.grid(colors, colors) #Give us all permutations of our colors

#3- Removing permutations where both bands are the same color
BirdID <- subset(BirdID, Var1 != Var2) 
BirdID$BirdID <- paste(BirdID$Var1, BirdID$Var2, sep="") #Make a column which is the combination of these colors

#clean up our colors vector
rm(colors)

```

This gives us a total of 30 possible Bird IDs, from which we can easily derive our total number of 60 "participants"

In the real world, we have a finite set of colors for banding, and we are ultimately looking for maximal distinctiveness in the bands we apply to our birds. To use R to set up a banding scheme in the future, consider [Appendix 3- Maximally Distinct Banding Patterns](#MaxDistinct)).

### Creating our Experimental permutations (Participants)

In this case we have an easy job - each of our 30 birds is going to be tested at both Dawn and in the Afternoon. We'll call these "Participants", mostly because we then have language that can apply to other experiments and be generalised a little bit more easily by novices who might be working with people, cockroaches, or anything other than birds!

```{r Experimental Permutations, message= FALSE, warning = FALSE}

#1- Creating a vector of Trial Types
TrialType <- c("Dawn", "Afternoon")

#Obtaining all permutations of BirdID and Trial Type
Participants <- expand.grid(BirdID$BirdID, TrialType)

#Renaming the columns of our "Experiments" dataframe
colnames(Participants) <- c("BirdID", "TrialType")

#Cleaning up now unnecessary vectors/dataframes
rm(BirdID, TrialType)

```


So now we have our list of Participants (crossings of Bird ID and Trial Type, such that each of our 30 birds is going to be tested at both times of day)

So, that's still not very much - what we need to do next is to choose which stimuli will be used for each Participant (each bird at each time)

### Assigning Stimuli

There are a few ways that we could assign stimuli in a case like this one - but generally we want to do so randomly - for each of our 60 participants we want to choose 10 of our 40 songs, then present each of those songs in their Control, Slow, and Fast format.

Actually, its a bit more complicated than that, because we don't want the same songs to appear in both the Afternoon and Dawn Trial Types. Here I assume we want completely separate songs for both types.

Because we're ultimately going to create 60 stimlists, we'll eventually have to write some sort of [function](https://www.tutorialspoint.com/r/r_functions.htm#:~:text=R%20has%20a%20large%20number,function%20to%20accomplish%20the%20actions.), or at least a [for loop](https://www.datamentor.io/r-programming/for-loop/) that can put together and export our stimlists. But for now, we're going to focus on a single case: Bird `r Participants$BirdID[5] ` at `r Participants$TrialType[5] `.

We will assign stimuli for this Participant in the following fashion, which we'll do using pipes!

1. Create our list of "Base Songs" - which are the unmodified songs (i.e. the same as our control songs) using [enframe](https://tibble.tidyverse.org/reference/enframe.html)
    *Getting rid of the parts we don't want with str.replace (file paths and extensions)
    *Separate the "Song" column back into its components: Song Number and Song Type
    *Subset so there are only "Control" songs in the list
    
2. We will sample 20 Songs from our list of Base Songs using the [sample](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/sample) function

3. Create a list of all songs for the participant where each song type (Control, Fast, Slow) is seen once, but never in the same block of 10 trials. So if in the first block of ten trials they hear the "Fast" version of Song 1, they will not hear another version of Song 1. Because we need to sample multiple times, we'll do this using the [replicate](https://www.rdocumentation.org/packages/Rpdb/versions/2.2/topics/replicate) function.


4. Assign 10 of these songs to "Dawn" and 10 to "Afternoon"

5. Reorganise the dataframes into their mini blocks

```{r Assigning Stimuli - Single Case, message= FALSE, warning = FALSE}

#1- Creating our list of Base Songs from our list of BirdSongs
BaseSongs <- 
  BirdSongs %>%
    enframe(name = "number", value = "Song") %>%
      mutate(Song = str_replace_all(Song,  
        "C:/Users/Alan Nielsen/Google Drive/Experiments/Dave/Song Matching Experiment/Stimuli/Fake Stimuli/",
          "")) %>% #Remove the file paths from the names
        mutate(Song = str_replace_all(Song, ".aif", "")) %>% # Remove the file extensions
          separate(Song, into = c("SongNum", "SongType"), sep = "-", remove = FALSE) %>% #separate into components
            subset(SongType == "Control") %>% #Subsetting our data so we have only Control songs (our Base Songs)
              subset(select = -number) %>% #remove a useless column
                mutate_all(factor) #refactor all of the columns to drop unused levels

# There are many other ways we could have done this- we could have simply reconstructed this list then renamed the columns:
  BaseSongs2 <- cbind.data.frame(paste(rep("Song ", 40), 1:40, rep("-Control", 40), sep = ""),
                                            paste(rep("Song", 40), 1:40), 
                                              rep("Control", 40)) 
    colnames(BaseSongs2) <- c("Song", "SongNum", "SongType")
    identical(BaseSongs$Song, BaseSongs2$Song) #Verify that they are identical

  
# Or we could have made things slightly simpler by using dir to get our list of files without paths, which would have cut a bit

BaseSongs3 <- dir(here("Stimuli/Fake Stimuli"), pattern = ".aif") %>%
    enframe(name = "number", value = "Song") %>%
        mutate(Song = str_replace_all(Song, ".aif", "")) %>% # Remove the file extensions
          separate(Song, into = c("SongNum", "SongType"), sep = "-", remove = FALSE) %>% #separate into components
            subset(SongType == "Control") %>% #Subsetting our data so we have only Control songs (our Base Songs)
              subset(select = -number) %>% #remove a useless column
                mutate_all(factor)  #refactor all of the columns to drop unused levels


          
#2- Sample from our list of Base Songs
ChosenSongs <- factor(sample(BaseSongs$SongNum, 20)) #Note we include factor() here to drop unused levels of the factor

#3- Create a list of all song types that is scrambled
SongOrders <- as.vector(replicate(20, sample(c("Control", "Fast", "Slow"), 3)))

AllSongs <- cbind.data.frame(rep(ChosenSongs, each = 3),
                                  as.vector(replicate(20, sample(c("Control", "Fast", "Slow"), 3))),
                                    rep(1:3, 20))

colnames(AllSongs) <- c("SongNum", "SongType", "SongAppearance")

#4- Assign half of the songs to Dawn and half to afternoon
DawnSongs <- AllSongs[1:30,]
AfternoonSongs <- AllSongs[31:60,]

#5- 
DawnSongs <- rbind.data.frame(sample(subset(DawnSongs, SongAppearance == 1),10),
                              sample(subset(DawnSongs, SongAppearance == 2),10),
                              sample(subset(DawnSongs, SongAppearance == 3),10))



```




















#Appendices

These sections are not strictly necessary for setting up or analysing data of this type, but are here simply because they offer interesting opportunities for using R in the future

## Appendix 1 - Choosing Song Stimuli I{#ChoosingSongs}
Imagine we have a big set of birdsongs of various types, from which we need to choose stimuli for our experiment. Lets look at how that would work

## Appendix 2 - Choosing Song Stimuli II{#ChoosingSongs2}
Imagine we have less "song types" than the number of songs we need to set up our experiment. Lets look at how we might do that

## Appendix 3 - Maximally Distinctive Banding Patterns{#MaxDistinct}

Imagine that we have a set of colored bands, and we can put 3 on any given bird, but we want to make sure that our choice of bands for each bird is maximally distinctive. How might we go about doing that?















## Initial annotation, file extraction, and naming conventions

Files for this experiment came in from field recordings and weren't named consistently. The naming conventions used for files derived from these by various workers on the project 

We start with the following for combination of Bird x Recording Time

a) A stimulus track containing the randomized-order songs played to the focal bird in the field
b) Experimental (recordings)
c) Single audio tracks for exemplars of the stimuli used in the stimulus track, labelled appropriately (e.g. ddlb-A-Fast)

In this first stage, we need to do the following

i) Locate the first song in the experimental track and note its time
ii) Do preliminary annotation of the Stimuli track (noting order of song presentation)
iii) Align the Stimuli Track with the Experimental Track (so we know what Stimuli are presented when)

The first and second of these tasks are done in Raven. In the non-R way of proceeding to step 3, we took the information from step i and inserted it manually into the annotation for the Stimuli Track.

For example if the first stimuli occured at 301.46 s we'd simply add that value to the start and end times of our text file (csv) of the annotated stimuli track.

Doing this process manually introduces many places for possible errors. This is what was done in the actual experiment, but here we're presenting best practices

So lets kill two birds with one stone: Alinging our audio tracks to prepare for full annotation, and starting to standardize some of our naming conventions

### Aligning Audio Tracks

Our approach to aligning audio tracks involves reading all of the .txt files (or .csv) files obtained in steps i and ii to combined individual files, and then aligning these

To do this, we're going to create two separate folders - one called "Stimtracks" and one called "Experiment Tracks". We can then put each of the files for each bird into these folders (best practices- we'd just have saved the files directly into this folder)

Here I'm going to use 3 birds as examples - you can see the text files in the appropriate folders. (Note that for the actual data for this experiment, I cannot reconstruct this step - for many birds we have only stimtracks and then completed annotated files.) (Note also that the naming varies widely. We're going to attempt to deal with this entirely in script, but its possible that some file-renaming will be required before runnings scripts if you have a larger dataset (another reason to keep naming systematic and delimited)


#### Stimulus Tracks

Stimulus tracks for each combination of bird x time are saved in the Stimtracks folder. These Stimtracks contain the order that the stimuli were presented in for that trial of an experiment, including their timings. However, there are some infelicities of style and naming/coding conventions. To see this clearly, lets take a look at the files, which we will do by putting them into a single data frame

##### Combining our Stimulus Tracks into a single dataframe
To get all of our files into a data frame we will:

1. Get the names of the files in our Stimtracks folder
  + Using [here](https://github.com/jennybc/here_here) to specify the directory (this is much less fragile than the approach of using [setwd](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/getwd) from base r), and allows the code to work across multiple machines)
  + Using [dir or list.files](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/list.files) to obtain the names of the files in the folder we point to with *here*
2. Read in the files in that directory into a list of lists using  [lapply](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lapply) 
  + Note that we can explore the individual StimTracks in this list by exploring their individual [indices](https://www.r-tutor.com/r-introduction/vector/vector-index), e.g. temp[[1]], temp[[2]], etc., which we do here by also using the [head](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/head) function to only look at the first few rows of the index
3. Transform our list of lists into a single dataframe using [bind_rows](https://dplyr.tidyverse.org/reference/bind.html)


```{r Combining Stimtracks, message= FALSE, warning = FALSE}
#1 - Get the names of the files in our Stimtracks folder
StimTracks <- dir(here("Stimuli/Original Recordings/Stimtracks"), full.names= TRUE, pattern = "\\.txt") #Note we use full.names = TRUE here so the file names have their file paths and can be referenced further down

#2 - Read in the files from that directory
temp <- lapply(StimTracks, fread, sep = "\t")

#2a - Explore an index (just to show how it is done)
head(temp[[2]])

#3 - Transform our lists of lists into a dataframe 
AggregatedStimTracks <- bind_rows(temp)
head(AggregatedStimTracks)

#Clean up our temp file
rm(temp)

```


##### Recovering our filenames

In the process of reading our files in this way, we've lost something - their filenames, which in this case are incredibly informative: they tell us which bird was recorded and at what time (A vs Dawn). We need to recover that data and add it back to our dataframe, which we will do by:

1. Obtaining a list of our filenames without their directories, again using [dir](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/list.files), but omitting the full.names argument
2. Adding a column to our dataframe that has the filename for each set of observations. 
  * In this case, this is simple - we know that each StimTrack has 60 lines: a waveform and a spectrogram for each of the ten songs (each played three times), so we can do this easily using [rep](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/rep) with the *each* argument applied

```{r Recovering filenames, message= FALSE, warning = FALSE}
#1- Obtaining filenames
StimTracks2 <- dir(here("Stimuli/Original Recordings/Stimtracks"), pattern = "\\.txt")

#2 Adding our filename column
AggregatedStimTracks$FileName <- rep(StimTracks2, each= 60)
```

##### Infelicities of Style - Cleaning up and standardising our data

If we take a look at this newly added FileName column, we see the first of the major problems that has come with having multiple collaborators on this project - different file naming conventions.

Our three files are named as such:

`r kable(as.data.frame(StimTracks2))` \ 

Fortunately, we can get rid of these at the same time as extracting the part of the filenames that we actually want - the ID of the bird and the recording time (A or Dawn). Also, despite naming inconsistencies, all files at least start with the same naming scheme - Bird ID then Trial Time.

However, they use different delimiters - the first file uses dashes, while the others use a combination of spaces and periods.

To split these strings up easily, they need to use the same delmiter/separator. To get there, we will

1. Replace all spaces with dashes (-)
2. Replace all periods with dashes (-)
  * For both of these, we will use [str_replace](https://www.rdocumentation.org/packages/stringr/versions/1.4.0/topics/str_replace)
    * You will note below that the code for what we are replacing is a bit strange looking - i.e. when we are replacing periods we actually use "\\." as the argument to the function. This is because in [RegEx](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html) the period (.) is a special character. Thus we include "\\" to "escape" the character - i.e. we're telling str_replace "forget what you think "." means - we're interested in the actual character itself!
3. Separate our FileName column into meaningful columns for the Bird's ID and Trial Type (A vs Dawn) using [separate](https://www.rdocumentation.org/packages/tidyr/versions/0.8.3/topics/separate)

*It is worth noting that the separate code is smart by virtue of being dumb - it will take the bird and trial type data (always the first two pieces of the filename) and throw out the rest, as well as getting rid of the now "useless" filename column*
    
```{r Replacing separators and creating needed columns , message= FALSE, warning = FALSE}

#1- Replace all spaces with dashes
AggregatedStimTracks$FileName <- str_replace(AggregatedStimTracks$FileName, " ", "-")

#2- Replace all periods with dashes (note the use of the escape on "\\." noted above)
AggregatedStimTracks$FileName <- str_replace(AggregatedStimTracks$FileName, "\\.", "-")

#3- Separate our filename column
AggregatedStimTracks <- separate(AggregatedStimTracks, FileName, into= c("Bird", "TrialType"), sep = "-", remove = TRUE)
```

##### Piped Version

1. We can also accomplish all of this using pipes in a single chunk of code. Most of this is done using the [mutate](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/mutate) function from dplyr

2. Subsequently, we can test if our two data frames are identical using the [identical](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/identical) function, which will return **TRUE** if these are the same (this is always a good way to verify whether we've written pipes correctly when we're translating code)

```{r Combining Stimtracks - Piped, message= FALSE, warning = FALSE}
#Read in filenames
StimTracks <- dir(here("Stimuli/Original Recordings/Stimtracks"), pattern = "\\.txt", full.names = TRUE)
StimTracks2 <- dir(here("Stimuli/Original Recordings/Stimtracks"), pattern = "\\.txt")


#1- All In one (note this also means not generating temp files that we need to clean up)
AggregatedStimTracks.p <-
  dir(here("Stimuli/Original Recordings/Stimtracks"), full.names= TRUE, pattern = ".txt") %>% #Getting filenames from directory
    lapply(fread, sep = "\t") %>% #Reading in all files to a list of lists
      bind_rows() %>% #Binding our list of lists into a dataframe
        mutate(FileName = rep(StimTracks2, each= 60)) %>% # Adding filename column
          mutate(FileName = str_replace_all(FileName, " ", "-")) %>% #replace spaces
            mutate(FileName = str_replace_all(FileName, "\\.", "-")) %>% #replace periods
              separate(FileName, into = c("Bird", "TrialType"), sep = "-", remove = TRUE) %>% #Separate into useful columns
                mutate(Combo = paste(Bird, TrialType, sep = "-")) # Paste together into a combo column


#2- Checking whether we've come up with the same output - this should evaluate as "TRUE" if we've done it right
identical(AggregatedStimTracks, AggregatedStimTracks.p)

#For some bizarre reason this shows as not identical, but we can collapse all the columns from each using unite and show that they are indeed the same
Agg <- unite(AggregatedStimTracks, newCol)
Agg$newCol2 <- unite(AggregatedStimTracks.p, newCol2)

identical(Agg$newCol, Agg$newCol2)

```


##### Resaving files (optional)

So, you might go through all of this with a larger set of files, but then want to clean up your file system so that some of this code is unnecessary in future (e.g. this kind of file renaming/cleaning may be something you don't want to include in your GitHub repository, as it looks somewhat unprofessional). You can do this by cutting our dataframe back apart into separate files (which are now csvs instead of .txt files)

Here we do that by:

1. Making a combo column of Bird ID x Trial Type using paste

2. Separating our dataframe into multiple dataframes using [split](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/split), which separates the data into a list of dataframes that can be reached by their indices (e.g. splits[1]) or by their names (e.g. splits$`kdk-A`)

3. Outputting these separate dataframes to files into the ReSaved folder using lapply and write.csv


```{r Resaving Files , message= FALSE, warning = FALSE, results = "hide"}
#1- Combo Column
AggregatedStimTracks$Combo <- paste(AggregatedStimTracks$Bird, AggregatedStimTracks$TrialType, sep = "-")

#2- Separating the dataframe
splits <- split(AggregatedStimTracks, AggregatedStimTracks$Combo)

#3- Outputting our files
lapply(1:length(splits), function(i) write.csv(splits[[i]], 
        file = paste0(here("Stimuli/Original Recordings/Stimtracks/ReSaved"),"/", names(splits[i]), ".csv"), 
                                            row.names = FALSE))

#remove the temporary splits file
rm(splits)


```




































```{r Aligning Audio Tracks}

#From this filename we need to extract the important bits - just the ID of the bird and the recording time (A or Dawn)
## Looking at the file structure that we have, in our current filenames we could just replace both spaces (" ") and periods (".") with dashes, and this would allow us to sensibly extract the important bits using only a single delimiter ("-"), which best-practice wise should be the delimiter for all file naming (or at least is my preferred one)
### We will do this with str_replace
AggregatedStimTracks %<>%
    mutate(FileName = str_replace_all(FileName, " ", "_"))
AggregatedStimTracks %<>%
    mutate(FileName = str_replace_all(FileName, "\\.", "_"))
# If you're wonder what the \\ is here, try running the code without it. In RegEx, "." is a special character with a meaning (the start of a string). We use \\ to "escape" the character - i.e. we're telling str_replace- "forget what you think '.' means - we're interested in the actual character"

#Now we can separate the Bird ID and Trial Type (A vs Dawn) into two columns in the dataframe and get rid of the rest
AggregatedStimTracks %<>%
  separate(FileName,
           into = c("Bird", "TrialType"),
           sep = "-", remove = TRUE)
#### The above code is smart (by virtue of being dumb) - it will take the bird and trial type (always at the start of the name) and throw out the rest, as well as getting rid of the now "useless" filename column

##########################################################################
```

The above read in our Stimtracks - standardising naming and giving us a nice data frame. Now we need to do the same, but for our Experiment Tracks, so that the two can be aligned

```{r Aligning Audio Tracks II}
#We'll assemble all of our Experiment Tracks into a single data frame, as we did above (but with more compact code)
setwd("C:/Users/Alan Nielsen/Google Drive/Experiments/Dave/Song Matching Experiment/Stimuli/Original Recordings/Experiment Tracks/")
ExpTracks <- dir()
AggregatedExpTracks <- rbindlist(lapply(ExpTracks, fread, sep = "\t")) #Note this does the same as above, but combines the code into one line with nesting 

#This could also be written with pipes as below

 # AggregatedExpTracks <- 
 #  ExpTracks %>%
 #    lapply(fread, sep = "\t") %>%
 #      rbindlist()



#### Here we can see things are a little bit messier - this is largely because of the types of files we've actually read in here - because they are messy. Actual best practice here would likely be to keep a single csv file that has the start and end of the first track for every bird x trial type - we could then just read that in for reference. 

#### Because of the state of our current data, we are going to pretend that is what we have

starttimes<- c("306.54", "297.18", "318.01") #making up some start times
endtimes <- c("308.01", "300.09", "319.16") #making up some end times

ExpTrackTimes <- cbind.data.frame(ExpTracks, starttimes, endtimes)

#### Note that with non-messy data (i.e. if we had files where only the first trial for each bird was identified) we could easily extract this list ourselves. Any approach to do so from the current messy data would instead require us to identify the first occurence of a "S" (stimuli) in each csv file and extract those. 

#### I do this below

#First, we subset out our ExperimentTracks so that we only have stimuli in it, which are coded as "s" in the column "Signal Type"
AggregatedExpTracks.Stims <- subset(AggregatedExpTracks, `Signal Type` == "s")

#What we should extract from this is a list of 180 lines (60 for each file), but we see we end up with 118... which isn't possible. Why is this?

#One way to figure this out is to see what is in the "Stim Type" column, which we can do a number of ways
#Here we are going to use the table function, because it gives us counts

as.data.frame(table(AggregatedExpTracks$`Signal Type`))

#We can see that there are a lot of things in that Signal Type column - c, C, r, R, s, S, and others. This is not ideal, and shows how non-standard the data entry is here. So lets rehearse what we actually want in that column

# In short, we should expect 5 possible values 
  # S = Stimuli
  # C = Comment
  # R = Response
  # Pr = Pre-Trial Song
  # Po = Post-Trial Song

# Everything we see here falls into those categories - but R is case sensitive, so we can't have some being capitalised, some not, different spellings, etc. We also shouldn't have any blank values in these columns - everythign we see here is at least one of those things, so lets clean this up

#NB That with the full data set, you'd likely have a *lot* more to clean up here, because data entry is all over the board - i.e. don't think you can just take this code and run it on the full set

#Single character entries are great for annotation, but lets keep things descriptive here within R- this will output easier to read statistics and graphs - so we'll call things what they are (e.g. we'll replace "s" and "S" with "Stimuli")

# To start, lets figure out what those blank spaces are
subset(AggregatedExpTracks, `Signal Type` == "")

#We see above that in the notes these are marked as "PreTrial", which we can assume means they are Pre Trial Songs

#What about the S/R?
TroubleTracks <- subset(AggregatedExpTracks, `Signal Type` == "S/R")

TroubleTracks

#We can see that this is a stimulus with an overlapping response - but this is not how such a thing should be noted in this experiment - there should be separate lines for the Stimulus and the Response, even when they overlap perfectly (because S/R is useless in data analysis), so we need to fix that, which we will do by:

AggregatedExpTracks <- subset(AggregatedExpTracks, `Signal Type` != "S/R") #1 Removing the duplicated entry from the main dataframe

#2 Recoding a copy of that data to contain *only* the features of a Stimuli
TroubleTracks1<- TroubleTracks
TroubleTracks1$`Signal Type` <- c("S", "S") 
TroubleTracks1$Response <- c("", "")

#3 Recoding a copy of that data to contain *only* the features of Response
TroubleTracks2 <- TroubleTracks
TroubleTracks2$`Signal Type` <- c("R", "R") 
TroubleTracks2$`Stim Type` <- c("", "")

#4 Adding these lines back into the main dataframe, then deleting these unnecessary dataframes
AggregatedExpTracks <- rbind_list(AggregatedExpTracks, TroubleTracks1, TroubleTracks2)
rm(TroubleTracks, TroubleTracks1, TroubleTracks2)



```

So now we (in theory) have a list of Start and End times for where our Stimtracks begin in the Experiment tracks, and we can align the two

```{r Aligning Audio Tracks III}






```






#Step 1 - Read in All Raven Data

The first step in doing


















































