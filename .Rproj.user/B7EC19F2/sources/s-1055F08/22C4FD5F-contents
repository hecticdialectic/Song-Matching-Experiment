---
title: "Logue Lab - Song Matching Experiment - Data Handling and Analysis"
output:   
  html_document:
    keep_md: true
    theme: journal
    toc: true
    toc_depth: 4
    toc_float: 
      collapsed: false
    code_folding: hide
---

```{r Loading Libraries, message= FALSE, warning = FALSE}
library(lme4)
library(plyr)
library(ggplot2)
library(afex)
library(emmeans)
library(ggthemes)
library(tidyverse)
library(kableExtra)
library(Hmisc)
library(binom)
library(Rmisc)
library(magick)
library(webshot)
library(magrittr)
library(multcomp)
library(data.table)
library(here)
library(sound)
library(audio)
library(seewave)
library(phonTools)
library(tuneR)
library(warbleR)
library(Rraven)
library(gdata) #for interleave

theme_alan <- function(base_size = 12 , base_family = "")
{
  half_line <- base_size/2
  colors <- ggthemes_data$few
  gray <- colors$medium["gray"]
  black <- colors$dark["black"]
  
  theme(
    line = element_line(colour = "black", size = 0.5, linetype = 1, lineend = "butt"),
    rect = element_rect(fill = "white", 
                        colour = "black", size = 0.5, linetype = 1),
    text = element_text(family = base_family, face = "plain", colour = "black", 
                        size = base_size, lineheight = 0.9, hjust = 0.5, vjust = 0.5,
                        angle = 0, margin = margin(), debug = FALSE),
    
    axis.line = element_blank(),
    axis.line.x = NULL,
    axis.line.y = NULL, 
    axis.text = element_text(size = rel(0.8), colour = "grey30"),
    axis.text.x = element_text(margin = margin(t = 0.8 * half_line/2), vjust = 1),
    axis.text.x.top = element_text(margin = margin(b = 0.8 * half_line/2), vjust = 0),
    axis.text.y = element_text(margin = margin(r = 0.8 * half_line/2), hjust = 1),
    axis.text.y.right = element_text(margin = margin(l = 0.8 * half_line/2), hjust = 0), 
    axis.ticks = element_line(colour = "grey20"), 
    axis.ticks.length = unit(half_line/2, "pt"),
    axis.title.x = element_text(margin = margin(t = half_line), vjust = 1),
    axis.title.x.top = element_text(margin = margin(b = half_line), vjust = 0),
    axis.title.y = element_text(angle = 90, margin = margin(r = half_line), vjust = 1),
    axis.title.y.right = element_text(angle = -90, margin = margin(l = half_line), vjust = 0),
    
    legend.background = element_rect(colour = NA),
    legend.spacing = unit(0.4, "cm"), 
    legend.spacing.x = NULL, 
    legend.spacing.y = NULL,
    legend.margin = margin(0.2, 0.2, 0.2, 0.2, "cm"),
    legend.key = element_rect(fill = "white", colour = NA), 
    legend.key.size = unit(1.2, "lines"), 
    legend.key.height = NULL,
    legend.key.width = NULL,
    legend.text = element_text(size = rel(0.8)), 
    legend.text.align = NULL,
    legend.title = element_text(hjust = 0),
    legend.title.align = NULL,
    legend.position = "right", 
    legend.direction = NULL,
    legend.justification = "center", 
    legend.box = NULL,
    legend.box.margin = margin(0, 0, 0, 0, "cm"),
    legend.box.background = element_blank(),
    legend.box.spacing = unit(0.4, "cm"),
    
    panel.background = element_rect(fill = "white", colour = NA),
    panel.border = element_rect(fill = NA, colour = "grey20"),
    panel.grid.major = element_line(colour = "grey92"),
    panel.grid.minor = element_line(colour = "grey92", size = 0.25),
    panel.spacing = unit(half_line, "pt"),
    panel.spacing.x = NULL,
    panel.spacing.y = NULL,
    panel.ontop = FALSE,
    
    strip.background = element_rect(fill = "NA", colour = "NA"),
    strip.text = element_text(colour = "grey10", size = rel(0.8)),
    strip.text.x = element_text(margin = margin(t = half_line, b = half_line)),
    strip.text.y = element_text(angle = 0, margin = margin(l = half_line, r = half_line)),
    strip.placement = "inside",
    strip.placement.x = NULL, 
    strip.placement.y = NULL,
    strip.switch.pad.grid = unit(0.1, "cm"), 
    strip.switch.pad.wrap = unit(0.1, "cm"), 
    
    plot.background = element_rect(colour = "white"),
    plot.title = element_text(size = rel(1.2), hjust = 0, vjust = 1, margin = margin(b = half_line * 1.2)),
    plot.subtitle = element_text(size = rel(0.9), hjust = 0, vjust = 1, margin = margin(b = half_line * 0.9)),
    plot.caption = element_text(size = rel(0.9), hjust = 1, vjust = 1, margin = margin(t = half_line * 0.9)), 
    plot.margin = margin(half_line, half_line, half_line, half_line),
    
    complete = TRUE)
}


```
# Introduction

The approach I'm taking here is to lay out all data wrangling and analyses using best practices. In future, this should get around issues of

a) file naming conventions
b) folder structure
c) "showing your work"

etc

That seem to plague multi-year and multi-student projects. Thus, this document will cover everything from experiment design to data analysis in order, with as many notes as I can put in as possible.

## Project Workflow

As with all things, its a great idea to lay out a project workflow. You can click on GO beneath to each of these sections to take you to the appropriate part of the document. You can also click through the table of contents for the same purpose.



# Experimental Design {#ExperimentDesign}

The first part of this project at least was collecting songs from birds. 

## Creating Stimlists
For most experiments, it is really beneficial to use the approach of creating Stimlists that are exhaustive, and that take the same format that our eventual data analysis will be happiest with - this keeps a through-line to our entire experiment where we always know what our columns mean, and can always relate data at any point to data from any other point and see how we got there, which is incredibly beneficial.

### Creating our Birdsong Stimuli
I am unsure what the original set of experimental stimuli was for this experiment, so we are reconstructing an idea of how to put this experiment together from scratch. But, for the sake of argument, **let's assume that we are creating our experiment based on 20 unique birdsongs**. These songs, without any manipulation, are our "Control" songs, but we can also either speed up ("Fast") or slow down ("Slow") these stimuli, giving us a total of 60 stimuli.

For the purposes of putting together this experiment, I've taken 60 random songs in ".wav" format and renamed them accordingly in the below code chunk by doing the following:

1. Ensuring that the destination folder (/Fake Stimuli) is empty by deleting all ".wav" files from the folder
```{r Creating Stimuli - Emptying Folder, message= FALSE, warning = FALSE, results = "hide"}
set.seed(49) #I'll come back to why we did this here later! For now you can ignore it
file.remove(dir(here("Simulated/Stimuli-Shared/Source Files"), pattern = ".wav", full.names = TRUE))
```

2. Copying all ".wav" files from the source folder (/Source) to the destinate folder (/Fake Stimuli)
```{r Creating Stimuli - Copy Files, message= FALSE, warning = FALSE, results = "hide"}
OriginalNames <- dir(here("Simulated/Stimuli-Shared/Source Files/Original"),  full.names = TRUE, pattern = ".wav") 
file.copy(from = OriginalNames,
          to = here("Simulated/Stimuli-Shared/Source Files"),
          overwrite = TRUE)
```

3. Retrieving the names of all files in the destination folder
```{r Creating Stimuli - Retrieving Names, message= FALSE, warning = FALSE, results = "hide"}
OldNames <- dir(here("Simulated/Stimuli-Shared/Source Files"),  full.names = TRUE, pattern = ".wav") 
```

4. Creating a list of filenames for the new files
```{r Creating Stimuli - Creating New Filename List, message= FALSE, warning = FALSE, results = "hide"}
BirdSongs <- paste(here("Simulated/Stimuli-Shared/Source Files"), "/",  #File Path
                  rep("Song ", 20),   #Just the word "Song" 20 times
                  rep(1:20, 3), "-", # The numbers 1:20 3 times in a row
                  rep(c("Control", "Fast", "Slow"), each = 20), #"Control" 20 times, then "Fast" 20 times, etc.
                  ".wav", sep = "" )
```

5. Renaming the files in the directory to the new names
```{r Creating Stimuli-Shared - Renaming files in the directory, message= FALSE, warning = FALSE, results = "hide"}
file.rename(OldNames, BirdSongs)
rm(OriginalNames, OldNames)
```


So now we have our set of songs, from which we want to construct our lists of stimuli (StimLists) for use in each playback experiment. 

In the real world, however, we'd likely be choosing this subset of songs for our experiment from a larger database of birdsongs from the species that we are studying- We might for example have say 1000 total songs from 50 birds that fall into 30 total song types (this is totally made up) - in such a case we would want a script that would choose randomly from this list in such a way that each Song Type was only used once. See [Appendix 1- Choosing Song Stimuli I](#ChoosingSongs) for an example of this kind of script.

In another case, there might actually be less than 20 overall Song Types, even though we need 20 individual songs for our Experiment for some reason. In this case, the selection procedure for each Stimlist would need to be a bit more careful. See [Appendix 2- Choosing Song Stimuli II](#ChoosingSongs2) for an example of this

### Creating Bird Band Permutations

For simplicity, we will assume here that we're going to be testing 30 birds, and we're going to test each of them in both types of trials (Dawn and A), so we'll have a total of 60 stimlists.

Lets set up the identities of our target birds. Obviously in the field this is done differently - but here we'll simply assume that each bird has two colored bands chosen from the following colors, but that no bird has two bands of the same color :
black (B), white (W), orange (O), red (R), green (G), yellow (Y). We can easily set up the permutations of these colors (and exclude two bands of the same color) by doing the following:

1. Creating a vector of our 6 color abbreviations
```{r Creating Stimuli - Color Vector, message= FALSE, warning = FALSE, results = "hide"}
colors <- c("B", "W", "O", "R", "G", "Y")
```

2. Obtaining the permutations of these colors using [expand.grid](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/expand.grid)
```{r Creating Stimuli - Color Permutations, message= FALSE, warning = FALSE, results = "hide"}
BirdID <- expand.grid(colors, colors)
```

3. Removing permutations where both bands are the same color using the [subset](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) function
```{r Creating Stimuli - Removing Permutations, message= FALSE, warning = FALSE, results = "hide"}
BirdID <- subset(BirdID, Var1 != Var2) 
BirdID$BirdID <- paste(BirdID$Var1, BirdID$Var2, sep="")
rm(colors)
```

This gives us a total of 30 possible Bird IDs, from which we can easily derive our total number of 60 "participants"

In the real world, we have a finite set of colors for banding, and we are ultimately looking for maximal distinctiveness in the bands we apply to our birds. To use R to set up a banding scheme in the future, consider [Appendix 3- Maximally Distinct Banding Patterns](#MaxDistinct)).

### Creating our Experimental permutations (Participants)

In this case we have an easy job - each of our 30 birds is going to be tested at both Dawn and in the Afternoon. We'll call these "Participants", mostly because we then have language that can apply to other experiments and be generalised a little bit more easily by novices who might be working with people, cockroaches, or anything other than birds!

```{r Experimental Permutations, message= FALSE, warning = FALSE}
#1- Creating a vector of Trial Types
TrialType <- c("Dawn", "Afternoon")

#Obtaining all permutations of BirdID and Trial Type
Participants <- expand.grid(BirdID$BirdID, TrialType)

#Renaming the columns of our "Experiments" dataframe
colnames(Participants) <- c("BirdID", "TrialType")

#Cleaning up now unnecessary vectors/dataframes
rm(BirdID, TrialType)

```


So now we have our list of Participants (crossings of Bird ID and Trial Type, such that each of our 30 birds is going to be tested at both times of day)

So, that's still not very much - what we need to do next is to choose which stimuli will be used for each Participant (each bird at each time)

### Assigning Stimuli

There are a few ways that we could assign stimuli in a case like this one - but generally we want to do so randomly - for each of our 60 participants we want to choose 3 of our 20 songs, then present one of those songs in its "Control" form, one in its "Slow" form, and one in its "Fast" form

Actually, its a bit more complicated than that, because we don't want the same songs to appear in both the Afternoon and Dawn Trial Types. Here I assume we want completely separate songs for both types.

Because we're ultimately going to create 60 stimlists, we'll eventually have to write some sort of [function](https://www.tutorialspoint.com/r/r_functions.htm#:~:text=R%20has%20a%20large%20number,function%20to%20accomplish%20the%20actions.), or at least a [for loop](https://www.datamentor.io/r-programming/for-loop/) that can put together and export our stimlists. But for now, we're going to focus on a single case: Bird `r Participants$BirdID[5]` at `r Participants$TrialType[5]`. After going through this piece by piece using standard R assignment, we'll write the same code with pipes for the `r Participants$TrialType[35]` trials.

#### The Single Case

We will assign stimuli for this Participant in the following fashion

1. Create our list of "Base Songs" - which are the unmodified songs (i.e. the same as our control songs) using [enframe](https://tibble.tidyverse.org/reference/enframe.html)
    *Getting rid of the parts we don't want with str.replace (file paths and extensions)
    *Separate the "Song" column back into its components: Song Number and Song Type
    *Subset so there are only "Control" songs in the list
```{r Creating Stimuli - Base Songs, message= FALSE, warning = FALSE, results = "hide"}
BaseSongs <- as.data.frame(dir(here("Simulated/Stimuli-Shared/Source Files"), pattern = ".wav"))

# Rename the column of this data frame to something meaningful (but a placeholder)
colnames(BaseSongs) <- "Songdata"

# Remove the file extensions
BaseSongs$Songdata <- str_replace_all(BaseSongs$Songdata, ".wav", "")

#Separate into two columns - SongNumber and SongType
BaseSongs <- separate(data = BaseSongs, 
                      col = Songdata, 
                      into = c("SongNum", "SongType"), sep = "-", remove = FALSE)

#Subset so we only have Control songs (our Base Songs)
BaseSongs <- subset(BaseSongs, SongType == "Control")

```
    
2. We will sample 6 Songs from our list of Base Songs using the [sample](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/sample) function
```{r Creating Stimuli - Sampling Base Songs, message= FALSE, warning = FALSE, results = "hide"}
ChosenSongs <- factor(sample(BaseSongs$SongNum, 6)) #Note we include factor() here to drop unused levels of the factor
```
    
3. Assign song speeds for both Trial Types - for each, one of the songs will be presented in its Control format, one in its Fast Format, and one in its Slow format. Because we need to sample multiple times, we'll do this using the [replicate](https://www.rdocumentation.org/packages/Rpdb/versions/2.2/topics/replicate) function.
```{r Creating Stimuli - Song Speeds, message= FALSE, warning = FALSE, results = "hide"}
Speeds <- c("Control", "Fast", "Slow")
SpeedOrder <- as.vector(replicate(2, sample(Speeds, 3))) #unfortunately the replicate function needs us to add "as.vector" to output data in a sensible format (i.e. not as a list of lists)
ChosenSongs <- paste(ChosenSongs, SpeedOrder, sep = "-") #Add our Speeds to the songs

rm(Speeds, SpeedOrder)
```
    
4. Assign half of these songs to Dawn and half to Afternoon, and save these stimuli to the appropriate folder
```{r Creating Stimuli - Assigning Song Speeds, message= FALSE, warning = FALSE, results = "hide"}
DawnSongs <- ChosenSongs[1:3]
DawnSongsS <- here("Simulated/Stimuli-Shared/Source Files", 
                   paste(DawnSongs, ".wav", sep = "") 
                   )
DawnSongsD <- here("Simulated/Single/Stimuli/Dawn", 
                   paste(DawnSongs, ".wav", sep = "") 
                   )

#Make sure destination folder is empty
file.remove(dir(here("Simulated/Single/Stimuli/Dawn"), pattern = ".wav", full.names = TRUE))

#Copy the chosen files
file.copy(from = DawnSongsS,
          to = DawnSongsD,
          overwrite = TRUE)
```
    
6. Set up the Dawn songs. For Dawn trials, songs are played in 10 blocks, where the order of presentation within the blocks is randomised. Thus we do this by sampling 10 times, using replicate
```{r Creating Stimuli - Dawn Songs Order, message= FALSE, warning = FALSE, results = "hide"}
DawnSongsList <- as.data.frame(as.vector(replicate(10, sample(DawnSongs, 3))))
colnames(DawnSongsList) <- "SongInfo"
DawnSongsList <- separate(data = DawnSongsList,
                           col= SongInfo,
                           into = c("SongNum", "SongSpeed"), sep = "-", remove = FALSE)
```
    
7. Reading in Sound files using the [load.wave](https://cran.r-project.org/web/packages/audio/audio.pdf) function from the "audio" package

```{r Creating Stimuli - Reading in our sound files, message= FALSE, warning = FALSE, results = "hide"}
Dawn1 <- load.wave(  here("Simulated/Single/Stimuli/Dawn", paste(DawnSongs[1], ".wav", sep = ""))  )
Dawn2 <- load.wave(  here("Simulated/Single/Stimuli/Dawn", paste(DawnSongs[2], ".wav", sep = ""))  )
Dawn3 <- load.wave(  here("Simulated/Single/Stimuli/Dawn", paste(DawnSongs[3], ".wav", sep = ""))  )
```

8. Inserting 10 seconds of silence at the start of each file using the [addsilw](https://www.rdocumentation.org/packages/seewave/versions/2.1.6/topics/addsilw) function of the 'seewave" package
```{r Creating Stimuli - Adding silence to sound files, message= FALSE, warning = FALSE, results = "hide"}
Dawn1silent <- addsilw(Dawn1, 
                       at = "start",
                       d = 10,
                       output = "audioSample")

Dawn2silent <- addsilw(Dawn2, 
                       at = "start",
                       d = 10,
                       output = "audioSample")

Dawn3silent <- addsilw(Dawn3, 
                       at = "start",
                       d = 10,
                       output = "audioSample")
```

9. Saving our files that have 10 seconds of silence added to them using [save.wave](https://cran.r-project.org/web/packages/audio/audio.pdf) from the "audio" package

Strictly speaking, we don't need to save these files - we're just going to append them into stimtracks - but its good practice to save things at each of our steps anyways so we know exactly what was used where
```{r Creating Stimuli - Saving our files with added silence, message= FALSE, warning = FALSE, results = "hide"}
file.remove(dir(here("Simulated/Single/Stimuli/Dawn"), pattern = "Silent.wav", full.names = TRUE))
save.wave(Dawn1silent, 
           where = here("Simulated/Single/Stimuli/Dawn", 
                  paste(DawnSongs[1],"-Dawn1-","Silent", ".wav", sep = "")))
save.wave(Dawn2silent, 
           where = here("Simulated/Single/Stimuli/Dawn", 
                  paste(DawnSongs[2],"-Dawn2-","Silent", ".wav", sep = "")))
save.wave(Dawn3silent, 
           where = here("Simulated/Single/Stimuli/Dawn", 
                  paste(DawnSongs[3],"-Dawn3-","Silent", ".wav", sep = "")))

```

10. Concatenating files into a stimtrack

Here we do this the most ugly way possible (to demonstrate the value of using lapply or writing a function/for loop)
```{r Creating Stimuli - Concatenating our files, message= FALSE, warning = FALSE, results = "hide"}
DawnSongsList$SongSel <- mapvalues(DawnSongsList$SongInfo,
                                 from = DawnSongs,
                                 to = c("Dawn1", "Dawn2", "Dawn3"))

DawnSongsList$SongPath <- here("Simulated/Single/Stimuli/Dawn", 
                               paste(
                                 DawnSongsList$SongInfo,  "-", DawnSongsList$SongSel, "-Silent.wav", sep = ""
                               ))

write.csv(DawnSongsList, here("/Simulated/Single/Stimlists", "DawnStims.csv"))
                               
DawnSongsTrack <- appendSample(DawnSongsList$SongPath[1],DawnSongsList$SongPath[2], DawnSongsList$SongPath[3],
                      DawnSongsList$SongPath[4],DawnSongsList$SongPath[5],DawnSongsList$SongPath[6],
                      DawnSongsList$SongPath[7],DawnSongsList$SongPath[8],DawnSongsList$SongPath[9],
                      DawnSongsList$SongPath[10],DawnSongsList$SongPath[11],DawnSongsList$SongPath[12],
                      DawnSongsList$SongPath[13],DawnSongsList$SongPath[14],DawnSongsList$SongPath[15],
                      DawnSongsList$SongPath[16],DawnSongsList$SongPath[17],DawnSongsList$SongPath[18],
                      DawnSongsList$SongPath[19],DawnSongsList$SongPath[20],DawnSongsList$SongPath[21],
                      DawnSongsList$SongPath[22],DawnSongsList$SongPath[23],DawnSongsList$SongPath[24],
                      DawnSongsList$SongPath[25],DawnSongsList$SongPath[26],DawnSongsList$SongPath[27],
                      DawnSongsList$SongPath[28],DawnSongsList$SongPath[29],DawnSongsList$SongPath[30])

saveSample(DawnSongsTrack, 
            here("Simulated/Single/Stimuli/Dawn", 
                  paste("Stimtrack-Dawn", ".wav", sep = "")),
           overwrite = TRUE)
```

11. Using [autodetec](https://marce10.github.io/warbleR/reference/autodetec.html) from the warbleR package to attempt to extract signals from the stimtrack files.

```{r Creating Stimuli - Autodetecting Signals, message= FALSE, warning = FALSE, results = "hide"}
setwd(here("Simulated/Single/Stimuli/Dawn")) #A really annoying case where I have to use setwd because autodetec is weird

Dawn.ad <- autodetec(flist = "./Stimtrack-Dawn.wav", 
                     threshold = 0, mindur = 0.5, 
                     envt = "abs", ssmooth = 900,   
                     output = "data.frame")


head(Dawn.ad) %>% 
  data.frame() %>% 
      mutate_if(is.numeric, round, digits = 3) %>% 
            knitr::kable(caption = "Autodetection of Signals in Stimtrack", ) %>%
              kable_styling(full_width= F)

```
This seems to do an **okay** job, but requires a lot of fiddling - not ideal, and it probably won't work on files that have a lot more noise in them without significantly more experience using warbleR, but we can at least check how good of a job this did selecting our songs/signals out of the track. We could, of course, do this by checking the selections in Raven, but for now lets keep things in R. We can compare to where the signals are, because we know exactly where the signals are - after all we put them there.

To do this we'll start by extracting the durations of our sound files using the [duration](https://rdrr.io/cran/seewave/man/duration.html) function from the "seewave" package.

12. Extracting the duration of sound files 
```{r Creating Stimuli - Duration of SoundFiles, message= FALSE, warning = FALSE, results = "hide"}
Durations <- c(duration(Dawn1), duration(Dawn2), duration(Dawn3))

```

13. Inserting columns with duration information into our dataframes using [mapvalues](https://www.rdocumentation.org/packages/plyr/versions/1.8.6/topics/mapvalues) from the "plyr" package

```{r Creating Stimuli - Mapvalues to insert durations, message= FALSE, warning = FALSE, results = "hide"}
DawnSongsList$Duration <- as.numeric(as.character(mapvalues(DawnSongsList$SongSel,
                                 from = c("Dawn1", "Dawn2", "Dawn3"),
                                 to = Durations)))

```

14. Reconstructing start times and end times. 
    * First we figure out the cumulative length of the appended sound files using [cumsum](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/cumsum) from base R. This is actually the End Time in seconds for each song clip in the stimtrack 
    * Then reconstruct the start time by subtracting the duration
    
```{r Creating Stimuli - Start and End TImes, message= FALSE, warning = FALSE, results = "hide"}
## Adding up the cumulative length
DawnSongsList$`End Time (s)` <- cumsum(DawnSongsList$Duration +10)
DawnSongsList$`Begin Time (s)` <- DawnSongsList$`End Time (s)` - DawnSongsList$Duration
```

15. Comparing to the values obtained from autodetec

```{r Creating Stimuli - Comparison to Autodetec, message= FALSE, warning = FALSE, results = "hide"}
## Adding up the cumulative length
DawnSongsList$`Begin Time (s) 2`<- Dawn.ad$start
DawnSongsList$`End Time (s) 2`<- Dawn.ad$end

## Computing differences
DawnSongsList$StartDiff <- DawnSongsList$`Begin Time (s)` - DawnSongsList$`Begin Time (s) 2`
DawnSongsList$EndDiff <- DawnSongsList$`End Time (s)` - DawnSongsList$`End Time (s) 2`
```

So actually it looks like our autodetec did pretty well - on average the difference between the begin/end times we input manually and those picked up by autodetec is only `r round(mean(abs(c(DawnSongsList$StartDiff, DawnSongsList$EndDiff))), 4)` seconds, with a minimum difference of `r round(min(abs(c(DawnSongsList$StartDiff, DawnSongsList$EndDiff))), 4)` seconds and a maximum difference of `r round(max(abs(c(DawnSongsList$StartDiff, DawnSongsList$EndDiff))), 4)` seconds.

If you're interested in how well autodetec does in less ideal circumstances, see [Appendix 4- Autodetection of Signals I I](#AutodetectionI).

16. Saving our stimtracks as maximally informative stimtrack csv files (in the same format as those used/generated by Raven) so that they can be read into Raven as the starting point for annotation.

We'll be making use of the [interleave](https://rdrr.io/cran/gdata/man/interleave.html) function from "gdata" to stick two data frames together perfectly riffle shuffled (also known as interleaving).

```{r Creating Stimuli - Creating Stimtrack Data Frame, message= FALSE, warning = FALSE, results = "hide"}
## Creating a bunch of vectors of columns that are needed 
Selection <- 1:30
View <- rep("Waveform 1", 30)
Channel <- rep(1, 30)
`Low Freq (Hz)` <- rep(0.0, 30)
`High Freq (Hz)` <- rep(22050.0, 30)
Bird <- rep(Participants$BirdID[5], 30)
`Trial Type` <- rep("Dawn", 30)
`Signal Type` <- rep("S", 30)
`Stim Type` <- DawnSongsList$SongSpeed
Response <- rep("", 30)
Overlapping <- rep("", 30)
Notes <- rep("", 30)
SongNum <- DawnSongsList$SongNum
SongSel <- DawnSongsList$SongSel
`Begin Time (s)`<- DawnSongsList$`Begin Time (s)`
`End Time (s)` <- DawnSongsList$`End Time (s)`

## Sticking our columns together into a dataframe that is named according to our naming convention
YBDawnStimtrack <- cbind.data.frame(Selection, 
                                      View, 
                                      Channel, 
                                      `Begin Time (s)`, 
                                      `End Time (s)`,
                                      `Low Freq (Hz)`,
                                      `High Freq (Hz)`,
                                      Bird,
                                      `Trial Type`,
                                      `Signal Type`,
                                      `Stim Type`,
                                      Response,
                                      Overlapping,
                                      Notes,
                                    SongNum,
                                    SongSel,
                                    DawnSongsList$Duration
                                      )

# Duplicating our dataframe, changing the "View" column to "Spectrogram 1", and then pasting it all back together and sorting
YBDawnStimtrack2 <- YBDawnStimtrack
YBDawnStimtrack2$View <- "Spectrogram 1"

YBDawnStimtrack <- interleave(YBDawnStimtrack, YBDawnStimtrack2)
```

17. Outputting our Stimtrack as a file

This part is pretty easy - we're just going to save our Stimtrack in the appropriate folder with the appropriate name

```{r Creating Stimuli - Outputting Stimtracks, message= FALSE, warning = FALSE, results = "hide"}
write.csv(DawnSongsList, 
          file = here("/Simulated/Single/Stimlists", 
            paste(YBDawnStimtrack$Bird[1], "-", YBDawnStimtrack$`Trial Type`[1], "-StimTrack.csv", sep ="")))
```

18. Clean up all the trash

We now don't need most of these vectors etc - so lets keep this project space clean and tidy

```{r Creating Stimuli - Cleaning Up, message= FALSE, warning = FALSE, results = "hide"}
#DAWN
rm(YBDawnStimtrack2, `Begin Time (s)`, Bird, BirdSongs, Channel, ChosenSongs, Dawn1, Dawn1silent, Dawn2, Dawn2silent,
   Dawn3, Dawn3silent,DawnSongs, DawnSongsD, DawnSongsS, Durations, `End Time (s)`, `High Freq (Hz)`, `Low Freq (Hz)`, Notes,
   Overlapping, Response, Selection, `Signal Type`, SongNum, SongSel, `Stim Type`, View, DawnSongsTrack, Dawn.ad, BaseSongs, Participants)
```

19. Generating our Afternoon stimtracks using pipes and the tidyverse

So far, we've been using standard assignment (left assignment, seen as <-) for running almost all of our functions.
In some ways, standard assignment is great - especially here where we have splitten up our work piece by piece, and especially while learning the basics of R.

But you can see in the code chunk above that we ended up having a bunch of intermediate dataframes and vectors that we then had to clean up to keep our virtual workspace tidy. These intermediate steps are great, because we can look at them as we go and make sure our code is working right.

But there is also another way. A tidy way. And one that is arguably easier to read for most cases (and that enables all sorts of additional methods of doing things). This way of doing things, that keeps everythign neat and tidy, and standardises how functions are called is known as the [tidyverse](https://hbctraining.github.io/Intro-to-R/lessons/08_intro_tidyverse.html). The most important part of the tidyverse being the use of [pipes](https://www.datacamp.com/community/tutorials/pipe-r-tutorial).

Below I'll write equivalent code to all of the previous 18 sections using pipes and much of the logic of the tidyverse (although I don't use [tibbles](https://r4ds.had.co.nz/tibbles.html) - this is a personal preference because I don't like tibbles, and probably not one you should follow).

##### Setting the Seed
One thing to return to before this chunk of code is my use of [set.seed](http://rfunction.com/archives/62) in the very first block of code after the setup block. 

In R (in all languages actually), whenever we use a function that relies on randomness - for example the sample() function, R decides how to do this based on a random seed. So every time we call sample() we'll get a different value. E.g. if we called sample(1:1000, 10), which samples 10 numbers randomly between 1 and 1000, we might get the following: Sample 1: `r sample(1:1000, 10)`, Sample 2: `r sample(1:1000, 10)`, Sample 3: `r sample(1:1000, 10)`




#### Creating multiple stimlists

So there you have it - two of the most basic possible stimlists














































































```{r As pipes}

BaseSongs <- 
  BirdSongs %>%
    enframe(name = "number", value = "Song") %>%
      mutate(Song = str_replace_all(Song,  
        "C:/Users/Alan Nielsen/Google Drive/Experiments/Dave/Song Matching Experiment/Stimuli/Fake Stimuli/",
          "")) %>% #Remove the file paths from the names
        mutate(Song = str_replace_all(Song, ".aif", "")) %>% # Remove the file extensions
          separate(Song, into = c("SongNum", "SongType"), sep = "-", remove = FALSE) %>% #separate into components
            subset(SongType == "Control") %>% #Subsetting our data so we have only Control songs (our Base Songs)
              subset(select = -number) %>% #remove a useless column
                mutate_all(factor) #refactor all of the columns to drop unused levels

# There are many other ways we could have done this- we could have simply reconstructed this list then renamed the columns:
  BaseSongs2 <- cbind.data.frame(paste(rep("Song ", 40), 1:40, rep("-Control", 40), sep = ""),
                                            paste(rep("Song", 40), 1:40), 
                                              rep("Control", 40)) 
    colnames(BaseSongs2) <- c("Song", "SongNum", "SongType")
    identical(BaseSongs$Song, BaseSongs2$Song) #Verify that they are identical

  
# Or we could have made things slightly simpler by using dir to get our list of files without paths, which would have cut a bit

BaseSongs3 <- dir(here("Stimuli/Fake Stimuli"), pattern = ".aif") %>%
    enframe(name = "number", value = "Song") %>%
        mutate(Song = str_replace_all(Song, ".aif", "")) %>% # Remove the file extensions
          separate(Song, into = c("SongNum", "SongType"), sep = "-", remove = FALSE) %>% #separate into components
            subset(SongType == "Control") %>% #Subsetting our data so we have only Control songs (our Base Songs)
              subset(select = -number) %>% #remove a useless column
                mutate_all(factor)  #refactor all of the columns to drop unused levels


          
#2- Sample from our list of Base Songs
ChosenSongs <- factor(sample(BaseSongs$SongNum, 20)) #Note we include factor() here to drop unused levels of the factor


#3- Assign half of the songs to Dawn and half to Afternoon
DawnSongs <- ChosenSongs[1:10,]
AfternoonSongs <- ChosenSongs[11:20,]


#4- Set up afternoon songs

AfternoonSongs <- rbind.data.frame(sample())



#3- Create a list of all song types that is scrambled
SongOrders <- as.vector(replicate(20, sample(c("Control", "Fast", "Slow"), 3)))

AllSongs <- cbind.data.frame(rep(ChosenSongs, each = 3),
                                  as.vector(replicate(20, sample(c("Control", "Fast", "Slow"), 3))),
                                    rep(1:3, 20))

colnames(AllSongs) <- c("SongNum", "SongType", "SongAppearance")

#4- Assign half of the songs to Dawn and half to afternoon
DawnSongs <- AllSongs[1:30,]
AfternoonSongs <- AllSongs[31:60,]

#5- 
DawnSongs <- rbind.data.frame(sample(subset(DawnSongs, SongAppearance == 1),10),
                              sample(subset(DawnSongs, SongAppearance == 2),10),
                              sample(subset(DawnSongs, SongAppearance == 3),10))


```







#Appendices

These sections are not strictly necessary for setting up or analysing data of this type, but are here simply because they offer interesting opportunities for using R in the future

## Appendix 1 - Choosing Song Stimuli I{#ChoosingSongs}
Imagine we have a big set of birdsongs of various types, from which we need to choose stimuli for our experiment. Lets look at how that would work

## Appendix 2 - Choosing Song Stimuli II{#ChoosingSongs2}
Imagine we have less "song types" than the number of songs we need to set up our experiment. Lets look at how we might do that

## Appendix 3 - Maximally Distinctive Banding Patterns{#MaxDistinct}

Imagine that we have a set of colored bands, and we can put 3 on any given bird, but we want to make sure that our choice of bands for each bird is maximally distinctive. How might we go about doing that?

## Appendix 4 - Autodetection of Signals I{#AutodetectionI}

Trying autodetec with more naturalistic recordings

## Appendix 5- Setting Seeds{#SettingSeeds}

rm(.Random.seed, envir=globalenv())   - Reset the seed to random

## Appendix 6- Setting Seeds- Yoking{#SettingSeeds- Yoking}





## Initial annotation, file extraction, and naming conventions

Files for this experiment came in from field recordings and weren't named consistently. The naming conventions used for files derived from these by various workers on the project 

We start with the following for combination of Bird x Recording Time

a) A stimulus track containing the randomized-order songs played to the focal bird in the field
b) Experimental (recordings)
c) Single audio tracks for exemplars of the stimuli used in the stimulus track, labelled appropriately (e.g. ddlb-A-Fast)

In this first stage, we need to do the following

i) Locate the first song in the experimental track and note its time
ii) Do preliminary annotation of the Stimuli track (noting order of song presentation)
iii) Align the Stimuli Track with the Experimental Track (so we know what Stimuli are presented when)

The first and second of these tasks are done in Raven. In the non-R way of proceeding to step 3, we took the information from step i and inserted it manually into the annotation for the Stimuli Track.

For example if the first stimuli occured at 301.46 s we'd simply add that value to the start and end times of our text file (csv) of the annotated stimuli track.

Doing this process manually introduces many places for possible errors. This is what was done in the actual experiment, but here we're presenting best practices

So lets kill two birds with one stone: Alinging our audio tracks to prepare for full annotation, and starting to standardize some of our naming conventions

### Aligning Audio Tracks

Our approach to aligning audio tracks involves reading all of the .txt files (or .csv) files obtained in steps i and ii to combined individual files, and then aligning these

To do this, we're going to create two separate folders - one called "Stimtracks" and one called "Experiment Tracks". We can then put each of the files for each bird into these folders (best practices- we'd just have saved the files directly into this folder)

Here I'm going to use 3 birds as examples - you can see the text files in the appropriate folders. (Note that for the actual data for this experiment, I cannot reconstruct this step - for many birds we have only stimtracks and then completed annotated files.) (Note also that the naming varies widely. We're going to attempt to deal with this entirely in script, but its possible that some file-renaming will be required before runnings scripts if you have a larger dataset (another reason to keep naming systematic and delimited)


#### Stimulus Tracks

Stimulus tracks for each combination of bird x time are saved in the Stimtracks folder. These Stimtracks contain the order that the stimuli were presented in for that trial of an experiment, including their timings. However, there are some infelicities of style and naming/coding conventions. To see this clearly, lets take a look at the files, which we will do by putting them into a single data frame

##### Combining our Stimulus Tracks into a single dataframe
To get all of our files into a data frame we will:

1. Get the names of the files in our Stimtracks folder
  + Using [here](https://github.com/jennybc/here_here) to specify the directory (this is much less fragile than the approach of using [setwd](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/getwd) from base r), and allows the code to work across multiple machines)
  + Using [dir or list.files](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/list.files) to obtain the names of the files in the folder we point to with *here*
2. Read in the files in that directory into a list of lists using  [lapply](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lapply) 
  + Note that we can explore the individual StimTracks in this list by exploring their individual [indices](https://www.r-tutor.com/r-introduction/vector/vector-index), e.g. temp[[1]], temp[[2]], etc., which we do here by also using the [head](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/head) function to only look at the first few rows of the index
3. Transform our list of lists into a single dataframe using [bind_rows](https://dplyr.tidyverse.org/reference/bind.html)


```{r Combining Stimtracks, message= FALSE, warning = FALSE}
#1 - Get the names of the files in our Stimtracks folder
StimTracks <- dir(here("Stimuli/Original Recordings/Stimtracks"), full.names= TRUE, pattern = "\\.txt") #Note we use full.names = TRUE here so the file names have their file paths and can be referenced further down

#2 - Read in the files from that directory
temp <- lapply(StimTracks, fread, sep = "\t")

#2a - Explore an index (just to show how it is done)
head(temp[[2]])

#3 - Transform our lists of lists into a dataframe 
AggregatedStimTracks <- bind_rows(temp)
head(AggregatedStimTracks)

#Clean up our temp file
rm(temp)

```


##### Recovering our filenames

In the process of reading our files in this way, we've lost something - their filenames, which in this case are incredibly informative: they tell us which bird was recorded and at what time (A vs Dawn). We need to recover that data and add it back to our dataframe, which we will do by:

1. Obtaining a list of our filenames without their directories, again using [dir](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/list.files), but omitting the full.names argument
2. Adding a column to our dataframe that has the filename for each set of observations. 
  * In this case, this is simple - we know that each StimTrack has 60 lines: a waveform and a spectrogram for each of the ten songs (each played three times), so we can do this easily using [rep](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/rep) with the *each* argument applied

```{r Recovering filenames, message= FALSE, warning = FALSE}
#1- Obtaining filenames
StimTracks2 <- dir(here("Stimuli/Original Recordings/Stimtracks"), pattern = "\\.txt")

#2 Adding our filename column
AggregatedStimTracks$FileName <- rep(StimTracks2, each= 60)
```

##### Infelicities of Style - Cleaning up and standardising our data

If we take a look at this newly added FileName column, we see the first of the major problems that has come with having multiple collaborators on this project - different file naming conventions.

Our three files are named as such:

`r kable(as.data.frame(StimTracks2))` \ 

Fortunately, we can get rid of these at the same time as extracting the part of the filenames that we actually want - the ID of the bird and the recording time (A or Dawn). Also, despite naming inconsistencies, all files at least start with the same naming scheme - Bird ID then Trial Time.

However, they use different delimiters - the first file uses dashes, while the others use a combination of spaces and periods.

To split these strings up easily, they need to use the same delmiter/separator. To get there, we will

1. Replace all spaces with dashes (-)
2. Replace all periods with dashes (-)
  * For both of these, we will use [str_replace](https://www.rdocumentation.org/packages/stringr/versions/1.4.0/topics/str_replace)
    * You will note below that the code for what we are replacing is a bit strange looking - i.e. when we are replacing periods we actually use "\\." as the argument to the function. This is because in [RegEx](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html) the period (.) is a special character. Thus we include "\\" to "escape" the character - i.e. we're telling str_replace "forget what you think "." means - we're interested in the actual character itself!
3. Separate our FileName column into meaningful columns for the Bird's ID and Trial Type (A vs Dawn) using [separate](https://www.rdocumentation.org/packages/tidyr/versions/0.8.3/topics/separate)

*It is worth noting that the separate code is smart by virtue of being dumb - it will take the bird and trial type data (always the first two pieces of the filename) and throw out the rest, as well as getting rid of the now "useless" filename column*
    
```{r Replacing separators and creating needed columns , message= FALSE, warning = FALSE}

#1- Replace all spaces with dashes
AggregatedStimTracks$FileName <- str_replace(AggregatedStimTracks$FileName, " ", "-")

#2- Replace all periods with dashes (note the use of the escape on "\\." noted above)
AggregatedStimTracks$FileName <- str_replace(AggregatedStimTracks$FileName, "\\.", "-")

#3- Separate our filename column
AggregatedStimTracks <- separate(AggregatedStimTracks, FileName, into= c("Bird", "TrialType"), sep = "-", remove = TRUE)
```

##### Piped Version

1. We can also accomplish all of this using pipes in a single chunk of code. Most of this is done using the [mutate](https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/mutate) function from dplyr

2. Subsequently, we can test if our two data frames are identical using the [identical](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/identical) function, which will return **TRUE** if these are the same (this is always a good way to verify whether we've written pipes correctly when we're translating code)

```{r Combining Stimtracks - Piped, message= FALSE, warning = FALSE}
#Read in filenames
StimTracks <- dir(here("Stimuli/Original Recordings/Stimtracks"), pattern = "\\.txt", full.names = TRUE)
StimTracks2 <- dir(here("Stimuli/Original Recordings/Stimtracks"), pattern = "\\.txt")


#1- All In one (note this also means not generating temp files that we need to clean up)
AggregatedStimTracks.p <-
  dir(here("Stimuli/Original Recordings/Stimtracks"), full.names= TRUE, pattern = ".txt") %>% #Getting filenames from directory
    lapply(fread, sep = "\t") %>% #Reading in all files to a list of lists
      bind_rows() %>% #Binding our list of lists into a dataframe
        mutate(FileName = rep(StimTracks2, each= 60)) %>% # Adding filename column
          mutate(FileName = str_replace_all(FileName, " ", "-")) %>% #replace spaces
            mutate(FileName = str_replace_all(FileName, "\\.", "-")) %>% #replace periods
              separate(FileName, into = c("Bird", "TrialType"), sep = "-", remove = TRUE) %>% #Separate into useful columns
                mutate(Combo = paste(Bird, TrialType, sep = "-")) # Paste together into a combo column


#2- Checking whether we've come up with the same output - this should evaluate as "TRUE" if we've done it right
identical(AggregatedStimTracks, AggregatedStimTracks.p)

#For some bizarre reason this shows as not identical, but we can collapse all the columns from each using unite and show that they are indeed the same
Agg <- unite(AggregatedStimTracks, newCol)
Agg$newCol2 <- unite(AggregatedStimTracks.p, newCol2)

identical(Agg$newCol, Agg$newCol2)

```


##### Resaving files (optional)

So, you might go through all of this with a larger set of files, but then want to clean up your file system so that some of this code is unnecessary in future (e.g. this kind of file renaming/cleaning may be something you don't want to include in your GitHub repository, as it looks somewhat unprofessional). You can do this by cutting our dataframe back apart into separate files (which are now csvs instead of .txt files)

Here we do that by:

1. Making a combo column of Bird ID x Trial Type using paste

2. Separating our dataframe into multiple dataframes using [split](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/split), which separates the data into a list of dataframes that can be reached by their indices (e.g. splits[1]) or by their names (e.g. splits$`kdk-A`)

3. Outputting these separate dataframes to files into the ReSaved folder using lapply and write.csv


```{r Resaving Files , message= FALSE, warning = FALSE, results = "hide"}
#1- Combo Column
AggregatedStimTracks$Combo <- paste(AggregatedStimTracks$Bird, AggregatedStimTracks$TrialType, sep = "-")

#2- Separating the dataframe
splits <- split(AggregatedStimTracks, AggregatedStimTracks$Combo)

#3- Outputting our files
lapply(1:length(splits), function(i) write.csv(splits[[i]], 
        file = paste0(here("Stimuli/Original Recordings/Stimtracks/ReSaved"),"/", names(splits[i]), ".csv"), 
                                            row.names = FALSE))

#remove the temporary splits file
rm(splits)


```




































```{r Aligning Audio Tracks}

#From this filename we need to extract the important bits - just the ID of the bird and the recording time (A or Dawn)
## Looking at the file structure that we have, in our current filenames we could just replace both spaces (" ") and periods (".") with dashes, and this would allow us to sensibly extract the important bits using only a single delimiter ("-"), which best-practice wise should be the delimiter for all file naming (or at least is my preferred one)
### We will do this with str_replace
AggregatedStimTracks %<>%
    mutate(FileName = str_replace_all(FileName, " ", "_"))
AggregatedStimTracks %<>%
    mutate(FileName = str_replace_all(FileName, "\\.", "_"))
# If you're wonder what the \\ is here, try running the code without it. In RegEx, "." is a special character with a meaning (the start of a string). We use \\ to "escape" the character - i.e. we're telling str_replace- "forget what you think '.' means - we're interested in the actual character"

#Now we can separate the Bird ID and Trial Type (A vs Dawn) into two columns in the dataframe and get rid of the rest
AggregatedStimTracks %<>%
  separate(FileName,
           into = c("Bird", "TrialType"),
           sep = "-", remove = TRUE)
#### The above code is smart (by virtue of being dumb) - it will take the bird and trial type (always at the start of the name) and throw out the rest, as well as getting rid of the now "useless" filename column

##########################################################################
```

The above read in our Stimtracks - standardising naming and giving us a nice data frame. Now we need to do the same, but for our Experiment Tracks, so that the two can be aligned

```{r Aligning Audio Tracks II}
#We'll assemble all of our Experiment Tracks into a single data frame, as we did above (but with more compact code)
setwd("C:/Users/Alan Nielsen/Google Drive/Experiments/Dave/Song Matching Experiment/Stimuli/Original Recordings/Experiment Tracks/")
ExpTracks <- dir()
AggregatedExpTracks <- rbindlist(lapply(ExpTracks, fread, sep = "\t")) #Note this does the same as above, but combines the code into one line with nesting 

#This could also be written with pipes as below

 # AggregatedExpTracks <- 
 #  ExpTracks %>%
 #    lapply(fread, sep = "\t") %>%
 #      rbindlist()



#### Here we can see things are a little bit messier - this is largely because of the types of files we've actually read in here - because they are messy. Actual best practice here would likely be to keep a single csv file that has the start and end of the first track for every bird x trial type - we could then just read that in for reference. 

#### Because of the state of our current data, we are going to pretend that is what we have

starttimes<- c("306.54", "297.18", "318.01") #making up some start times
endtimes <- c("308.01", "300.09", "319.16") #making up some end times

ExpTrackTimes <- cbind.data.frame(ExpTracks, starttimes, endtimes)

#### Note that with non-messy data (i.e. if we had files where only the first trial for each bird was identified) we could easily extract this list ourselves. Any approach to do so from the current messy data would instead require us to identify the first occurence of a "S" (stimuli) in each csv file and extract those. 

#### I do this below

#First, we subset out our ExperimentTracks so that we only have stimuli in it, which are coded as "s" in the column "Signal Type"
AggregatedExpTracks.Stims <- subset(AggregatedExpTracks, `Signal Type` == "s")

#What we should extract from this is a list of 180 lines (60 for each file), but we see we end up with 118... which isn't possible. Why is this?

#One way to figure this out is to see what is in the "Stim Type" column, which we can do a number of ways
#Here we are going to use the table function, because it gives us counts

as.data.frame(table(AggregatedExpTracks$`Signal Type`))

#We can see that there are a lot of things in that Signal Type column - c, C, r, R, s, S, and others. This is not ideal, and shows how non-standard the data entry is here. So lets rehearse what we actually want in that column

# In short, we should expect 5 possible values 
  # S = Stimuli
  # C = Comment
  # R = Response
  # Pr = Pre-Trial Song
  # Po = Post-Trial Song

# Everything we see here falls into those categories - but R is case sensitive, so we can't have some being capitalised, some not, different spellings, etc. We also shouldn't have any blank values in these columns - everythign we see here is at least one of those things, so lets clean this up

#NB That with the full data set, you'd likely have a *lot* more to clean up here, because data entry is all over the board - i.e. don't think you can just take this code and run it on the full set

#Single character entries are great for annotation, but lets keep things descriptive here within R- this will output easier to read statistics and graphs - so we'll call things what they are (e.g. we'll replace "s" and "S" with "Stimuli")

# To start, lets figure out what those blank spaces are
subset(AggregatedExpTracks, `Signal Type` == "")

#We see above that in the notes these are marked as "PreTrial", which we can assume means they are Pre Trial Songs

#What about the S/R?
TroubleTracks <- subset(AggregatedExpTracks, `Signal Type` == "S/R")

TroubleTracks

#We can see that this is a stimulus with an overlapping response - but this is not how such a thing should be noted in this experiment - there should be separate lines for the Stimulus and the Response, even when they overlap perfectly (because S/R is useless in data analysis), so we need to fix that, which we will do by:

AggregatedExpTracks <- subset(AggregatedExpTracks, `Signal Type` != "S/R") #1 Removing the duplicated entry from the main dataframe

#2 Recoding a copy of that data to contain *only* the features of a Stimuli
TroubleTracks1<- TroubleTracks
TroubleTracks1$`Signal Type` <- c("S", "S") 
TroubleTracks1$Response <- c("", "")

#3 Recoding a copy of that data to contain *only* the features of Response
TroubleTracks2 <- TroubleTracks
TroubleTracks2$`Signal Type` <- c("R", "R") 
TroubleTracks2$`Stim Type` <- c("", "")

#4 Adding these lines back into the main dataframe, then deleting these unnecessary dataframes
AggregatedExpTracks <- rbind_list(AggregatedExpTracks, TroubleTracks1, TroubleTracks2)
rm(TroubleTracks, TroubleTracks1, TroubleTracks2)



```

So now we (in theory) have a list of Start and End times for where our Stimtracks begin in the Experiment tracks, and we can align the two

```{r Aligning Audio Tracks III}






```






#Step 1 - Read in All Raven Data

The first step in doing


















































